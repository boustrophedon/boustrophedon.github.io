<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Pro-cantabrigian hypsidolichocephalism</title><link href="https://boustrophedon.github.io/" rel="alternate"></link><link href="https://boustrophedon.github.io/feeds/system-administration.atom.xml" rel="self"></link><id>https://boustrophedon.github.io/</id><updated>2015-03-04T02:56:20-05:00</updated><entry><title>How I'm deploying Dart server code on DigitalOcean</title><link href="https://boustrophedon.github.io/how-im-deploying-dart-server-code-on-digitalocean.html" rel="alternate"></link><updated>2015-03-04T02:56:20-05:00</updated><author><name>Harry Stern</name></author><id>tag:boustrophedon.github.io,2015-03-04:how-im-deploying-dart-server-code-on-digitalocean.html</id><summary type="html">&lt;p&gt;So I finally started to work on my multiplayer breakout clone in dart that I've been meaning to do forever. It's moderately functional now. This post is how I am deploying the server code on digitalocean. It's written mostly for someone who has maybe used a desktop linux environment and isn't completely lost on the command line, but who maybe hasn't set up a server before. Here is the short version:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create a new fedora droplet&lt;ul&gt;
&lt;li&gt;ssh keys&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;yum update (optional)&lt;/li&gt;
&lt;li&gt;create new user&lt;/li&gt;
&lt;li&gt;copy ssh keys to new user's directory&lt;ul&gt;
&lt;li&gt;make sure permissions are correct&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;add user to wheel&lt;/li&gt;
&lt;li&gt;remove root login from sshd_config&lt;/li&gt;
&lt;li&gt;add dartapps user&lt;ul&gt;
&lt;li&gt;useradd -r -s /sbin/nologin dartapps&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;download and unzip dart-sdk to /opt/&lt;/li&gt;
&lt;li&gt;symlink /opt/dart-sdk/bin/{dart,dart2js,pub} to /usr/bin/{dart,dart2js,pub}&lt;/li&gt;
&lt;li&gt;cd to /usr/local/bin and git clone the repo&lt;/li&gt;
&lt;li&gt;This is what I did originally to get deps working:&lt;ul&gt;
&lt;li&gt;if not running as root, switch to root&lt;/li&gt;
&lt;li&gt;run &lt;code&gt;PUB_CACHE=/usr/local/bin/dart-breakout/pub-cache pub get&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;You can also choose to do the previous step and the following on the server, or locally and scp the file:&lt;ul&gt;
&lt;li&gt;after getting the dependencies with pub get, create a build/ directory and run:
    &lt;code&gt;dart2js --categories=Server --output-type=dart bin/server.dart -o build/server.dart&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;create systemd unit file&lt;ul&gt;
&lt;li&gt;if building with dart2js, set the exec file accordingly&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;enable unit file&lt;/li&gt;
&lt;li&gt;start unit file&lt;/li&gt;
&lt;li&gt;yay&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;First, create a digitalocean droplet running Fedora (21 is the latest they have as of 3/15). You should probably choose to have your ssh key included.&lt;/p&gt;
&lt;p&gt;The next step is optional: Do a &lt;code&gt;yum update&lt;/code&gt;. This, of course, updates all of your packages and may take a little while. It will also most likely give you some security fixes that you probably want.&lt;/p&gt;
&lt;p&gt;Next we're going to create a new user so that you're not running as root all the time, because that is a bad idea. run &lt;code&gt;useradd NEWUSERNAME&lt;/code&gt; with whatever you want, and follow the directions. Add this user to wheel with &lt;code&gt;usermod -a -G wheel NEWUSERNAME&lt;/code&gt;, which will give it access to sudo. You can modify your /etc/sudoers (with &lt;code&gt;visudo&lt;/code&gt; !) so that you don't have to type your password for sudo, or not, depending on your preference. Finally, if you added ssh keys on droplet creation, copy them from .ssh/authorized_keys to /home/NEWUSERNAME/.ssh/authorized_keys and make sure to chown and chgrp your new /home/NEWUSERNAME/.ssh/ directory so it's owned by your new user.&lt;/p&gt;
&lt;p&gt;Since digitalocean provides console access via its web dashboard, there's really no reason to allow root logins from ssh, so now that we have a new user that we can log in to (check to make sure you can log in first; you may have to reboot the server) let's fix that. Edit /etc/ssh/sshd_config as root and uncomment the line &lt;code&gt;PermitRootLogin yes&lt;/code&gt;, and change yes to no. Try sshing to the droplet as root. If it still works, you need to restart the ssh server or at least reload the configs.&lt;/p&gt;
&lt;p&gt;Now we're going to create a user to run our dart server. We want it to have very few privileges on the system in case someone takes advantage of a vulnerability in the server and is able to execute arbitrary code, and it is also convenient for other purposes, like bandwidth-limiting, disk space quotas, other monitoring stuff that I'm not going to cover. I'm going to call this user 'dartapps' but you can call it whatever. To create it, run &lt;code&gt;useradd -r -s /sbin/nologin dartapps&lt;/code&gt;. The -r option makes the user a system user, without a home directory, and -s /sbin/nologin means that it doesn't have a login shell; you cannot login as this user even if you gave it a password.&lt;/p&gt;
&lt;p&gt;It is now time to install the dart sdk. Open https://www.dartlang.org/tools/download.html#other and copy the 64-bit linux download url. Download it into /opt and unzip it (you will probably need to &lt;code&gt;yum install unzip&lt;/code&gt;). In order to make things convenient, you can symlink any or all of the files in /opt/dart-sdk/bin/ to /usr/bin/ by doing &lt;code&gt;ln -s /opt/dart-sdk/bin/dart /usr/bin/dart&lt;/code&gt;, and similarly for the others. At the very least you will want to do this for the dart and pub commands. You may also need to &lt;code&gt;chmod o+rx /opt/dart-sdk/bin/dart&lt;/code&gt; if you cannot run e.g. &lt;code&gt;dart --help&lt;/code&gt; from your NEWUSERNAME user.&lt;/p&gt;
&lt;p&gt;At this point we finally get to download our own code. Either scp your server code, git clone it, or whatever, into some directory. I chose /usr/local/bin/dart-breakout/ for my breakout code, but it could just have easily gone into /srv/ or something. /srv may in fact be a better choice.&lt;/p&gt;
&lt;p&gt;There is an optional, somewhat unsupported step here: Instead of copying all your code over, you may, on your local development machine, create a build/bin directory in your pub package file structure. Then, run the following command, assuming your server dart code is in bin/server.dart: &lt;code&gt;dart2js --categories=Server --output-type=dart bin/server.dart -o build/bin/server.dart&lt;/code&gt;. This runs "dart2dart" on your code and puts it all in a single file, but instead of outputting js it outputs dart code. You may also do this on the server after getting the dependencies as explained in the next paragraph.&lt;/p&gt;
&lt;p&gt;If you did not follow the above optional step, this is what I originally did: Normally, pub downloads your packages into ~/.pub-cache. However, our dartapps user does not have a home directory. If we try to run &lt;code&gt;pub get&lt;/code&gt; as root, pub will install our dependencies into /root/.pub-cache, which is of course unreadable by the dartapps user. We can fix this by either creating a global pub-cache inside, say, /usr/local/include/ or /usr/local/lib/, but I chose the option of creating it inside my server's code directory, so /usr/local/bin/dart-breakout/pub-cache. This is already a bit messy and a mild abuse of /usr/local/bin, and the better option is to compile all your dart code to a single file as in the above step.&lt;/p&gt;
&lt;p&gt;In order to create this extra pub cache directory, we need to (as root), run &lt;code&gt;PUB_CACHE=/usr/local/bin/dart-breakout/pub-cache pub get&lt;/code&gt;. Setting the PUB_CACHE variable tells pub where to put the cache, and sets up the symlinks to point at that local cache for our application. Of course, be sure to substitute dart-breakout for your own name. You should test that the dependencies are installed and permissions are correct by running the server as a non-root user.&lt;/p&gt;
&lt;p&gt;Lastly, we get monitoring, logging, and restart-on-crash for free by creating a simple systemd unit file that runs our server as the dartapps user. Drop this file into /etc/systemd/system/dart-breakout.service, replacing dart-breakout in both the filename and inside the file as needed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[Service]&lt;/span&gt;
&lt;span class="na"&gt;ExecStart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/usr/bin/dart /usr/local/bin/dart-breakout/bin/server.dart&lt;/span&gt;
&lt;span class="na"&gt;Restart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;always&lt;/span&gt;
&lt;span class="na"&gt;StandardOutput&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;syslog&lt;/span&gt;
&lt;span class="na"&gt;StandardError&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;syslog&lt;/span&gt;
&lt;span class="na"&gt;SyslogIdentifier&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;dart-breakout&lt;/span&gt;
&lt;span class="na"&gt;User&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;dartapps&lt;/span&gt;
&lt;span class="na"&gt;Group&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;dartapps&lt;/span&gt;

&lt;span class="k"&gt;[Install]&lt;/span&gt;
&lt;span class="na"&gt;WantedBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;multi-user.target&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you followed the optional "dart2dart" step, replace the project/bin/server.dart file with the compiled file, which you would probably install to /usr/local/bin/ directly.&lt;/p&gt;
&lt;p&gt;And now we're done! Run (as root) &lt;code&gt;systemctl enable dart-breakout&lt;/code&gt; to enable the service to run on startup, and &lt;code&gt;systemctl start dart-breakout&lt;/code&gt; to start the server now. You can use &lt;code&gt;journalctl -u dart-breakout&lt;/code&gt; to view the output of your program.&lt;/p&gt;</summary><category term="dart"></category><category term="deployment"></category><category term="systemd"></category><category term="fedora"></category><category term="websockets"></category></entry><entry><title>How to make daily backups with rdiff-backup and systemd</title><link href="https://boustrophedon.github.io/how-to-make-daily-backups-with-rdiff-backup-and-systemd.html" rel="alternate"></link><updated>2014-09-12T02:02:54-04:00</updated><author><name>Harry Stern</name></author><id>tag:boustrophedon.github.io,2014-09-12:how-to-make-daily-backups-with-rdiff-backup-and-systemd.html</id><summary type="html">&lt;p&gt;The other day I was talking to one of my friends and he mentioned how he lost a hard drive recently and consequently all of his stuff. I realized that, although I had bought a backup hard drive a little while ago, I hadn't done more than a couple backups with it when I felt like it. So I decided that I would finally set up regular backups of my home directory.&lt;/p&gt;
&lt;p&gt;I'd looked briefly at backup solutions before and thought that &lt;a href="http://savannah.nongnu.org/projects/rdiff-backup"&gt;rdiff-backup&lt;/a&gt; seemed like a good choice. I also want to do snapshots at some point either with straight-up rsync or rsnapshot, but for now just the differential backups are probably fine. So I chose rdiff-backup.&lt;/p&gt;
&lt;p&gt;One easily-solved problem I encountered was that I have large data files that I don't have space to back up and that aren't super necessary to back up in the first place. However, I wanted to keep track of the files. So I'm using &lt;code&gt;rdiff-backup --exclude&lt;/code&gt; to exclude those directories, and then writing the output of &lt;code&gt;ls -lLR&lt;/code&gt; in those directories to a file to keep track of what's in them. Since the -l option tells us the modified times, I didn't think it was necessary to write the listing files out into my actual home directory and then have that be part of the backup. EDIT: On second thought, it actually is necessary to do so. If, for example, the entire directory we're saving the listing of was deleted, and then the backup script ran again, the listing would be overwritten with nothing and it would be pointless. So we need to do the listing before running the background and it needs to output to a directory that is going to be backed up.&lt;/p&gt;
&lt;p&gt;I combined these two steps into a python script that prints some information about what it's doing and then runs the commands. I always prefer python scripts to bash because you don't have to worry about escaping, or portability, or unreadability, or any of the other problems one encounters with shell scripting.&lt;/p&gt;
&lt;p&gt;The other half of the backup problem is actually running the backups. Putting a backup command in your crontab isn't the best idea for a desktop or laptop because it might be scheduled to run while your computer is off, resulting in a missed backup. &lt;a href="http://en.wikipedia.org/wiki/Anacron"&gt;Anacron&lt;/a&gt; is traditionally the solution to this: it runs cron jobs on a hourly/daily/monthly/whatever basis and, more importantly, will run jobs that were missed while the computer was off.&lt;/p&gt;
&lt;p&gt;However, I knew that systemd somewhat-recently gained support for doing cron-like things, and I knew that if I used systemd and wrote a unit file to run the backups, I could get the output easily and nicely into systemd's journal, making it easy to check that backups are running. If I put it in cron or anacron, which on my system are both covered by cronie, the output from my backup script would be mixed together with the other cronjobs' outputs. (I think.)&lt;/p&gt;
&lt;p&gt;So I wrote a simple .service unit file that runs the python script I wrote as a oneshot, and then wrote a .timer file which tells systemd to run the corresponding .service file with the same name daily (&lt;code&gt;OnCalendar=daily&lt;/code&gt;) and to run it ASAP if we missed the last time it was supposed to run (&lt;code&gt;Persistent=true&lt;/code&gt;). The service file also has some options to set the nice value to 19 (the lowest priority) and lower the IO priority. (&lt;code&gt;Nice=19&lt;/code&gt;, &lt;code&gt;IOSchedulingClass=2&lt;/code&gt;, &lt;code&gt;IOSchedulingPriority=7&lt;/code&gt;) These were mostly copied from &lt;a href="https://wiki.archlinux.org/index.php/Systemd/cron_functionality"&gt;this page on the arch linux wiki&lt;/a&gt;. Make sure to delete the in-line comments; they will cause errors if you try to actually use them as they are.&lt;/p&gt;
&lt;p&gt;I looked into using systemd user sessions to run these, but it seemed a bit complicated to set up and I wasn't entirely sure what the benefit was. Furthermore, I might use this script to do backups of /etc or something in the future, which would mean I wouldn't use a user session anyway. So instead I have the unit run as my own user (&lt;code&gt;User=username&lt;/code&gt;) and copied the .service and .timer files into &lt;code&gt;/etc/systemd/system/&lt;/code&gt;. I copied the python script that does the backups to &lt;code&gt;/usr/local/bin/backup-scripts/&lt;/code&gt;, though you could just leave it in &lt;code&gt;/usr/local/bin/&lt;/code&gt; just the same. The last step to make everything work is to enable the timer unit with something like &lt;code&gt;sudo systemctl enable my-backup.timer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It's probably irrational, but I feel a bit nervous making my script and unit files public even though the worst/best thing that would probably happen would be someone pointing out a way to make them better. Email me or something if you want to see them, I guess? that feels really lame.&lt;/p&gt;</summary><category term="backups"></category><category term="rdiff-backup"></category><category term="systemd"></category><category term="journalctl"></category><category term="cron"></category><category term="anacron"></category></entry></feed>